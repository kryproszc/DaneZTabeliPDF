from numpy.random import Generator, PCG64
from multiprocessing import Pool, cpu_count, freeze_support
import warnings
import math
import scipy.special as special
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

warnings.simplefilter(action="ignore", category=FutureWarning)

class PCG64Generator:
    def __init__(self, seed=202260011):
        self.seed = seed
        self.rng = Generator(PCG64(seed))

    def reset_rng(self):
        self.rng = Generator(PCG64(self.seed))

    def set_seed(self, seed):
        self.seed = seed
        self.reset_rng()

    def random(self, size=1):
        return self.rng.random(size)

    def normal(self, mu=0, sigma=1, size=1):
        return self.rng.normal(mu, sigma, size)

    def lognormal(self, mean=0, sigma=1, size=1):
        return self.rng.lognormal(mean, sigma, size)

    def chi_squared(self, df, size=1):
        return self.rng.chisquare(df, size)

class StochasticModel:
    def __init__(self, seed=202260011):
        self.seed = seed

    def process_row(self, args):
        seed, row, mu, sigma, mm, data_paid_copy, Ultimate_Param_ReservingRisk = args
        rng = PCG64Generator(seed)  # Inicjalizacja generatora losowego w procesie podrzędnym
        m_i, sigma_i = mu.iloc[row, :], sigma.iloc[row, :]
        for j in range(len(m_i)):
            max_ind_row = np.max([0, mm - j - 1])
            for i in range(max_ind_row, mm):
                VAR_i_j = (sigma_i[j]) / (data_paid_copy.iloc[i, j])
                lmean_i_j = np.log((m_i[j]) ** 2 / (np.sqrt((m_i[j]) ** 2 + VAR_i_j)))
                lstdev_i_j = np.log(1 + ((VAR_i_j) / ((m_i[j]) ** 2)))
                CL_i_j = rng.lognormal(lmean_i_j, lstdev_i_j, size=1)
                data_paid_copy.iloc[i, j + 1] = data_paid_copy.iloc[i, j] * CL_i_j[0]
        u_i = data_paid_copy.iloc[:, data_paid_copy.columns[-1] - 1].to_list()
        result_j = 1.29 * (np.sum(u_i) - Ultimate_Param_ReservingRisk)
        return result_j

    def random_stochastic_parameters(self, sigma_j, dev, sd, dimension):
        rng = PCG64Generator(self.seed)  # Inicjalizacja generatora losowego
        stochastic_sigma_j = pd.DataFrame(data=0, columns=np.arange(0, dimension[3], 1),
                                          index=np.arange(0, dimension[2], 1))
        mu_j = pd.DataFrame(data=0, columns=np.arange(0, dimension[3], 1),
                            index=np.arange(0, dimension[2], 1))
        for j in range(0, dimension[3]):
            mu_j.iloc[:, j] = rng.normal(dev[j], sd[j], size=dimension[2])
            st_swobody = np.max([1, dimension[0] - j])
            chi_list = rng.chi_squared(st_swobody, size=dimension[2])
            stochastic_sigma_j.iloc[:, j] = [(math.ceil(chi) * sigma_j[j]) / st_swobody for chi in chi_list]
        return [mu_j, stochastic_sigma_j]

    def stochastic_triangle_forward_test_szybki(self, data_paid, sigma_j, dev, sd, sim, Ultimate_Param_ReservingRisk):
        mm, nn = data_paid.shape[0], data_paid.shape[1]
        dimension = [mm, nn, sim, len(dev)]
        Total_BE = []
        mu, sigma = self.random_stochastic_parameters(sigma_j, dev, sd, dimension)
        data_paid_copy = data_paid.copy()
        data_paid_copy_reRe = data_paid.copy()
        data_paid_copy_reRe[mm + 1] = np.nan
        if len(dev) > mm:
            for k in range(mm + 1, len(dev) + 2):
                data_paid_copy[k] = np.nan
        args = [(self.seed, row, mu, sigma, mm, data_paid_copy.copy(), Ultimate_Param_ReservingRisk) for row in range(0, sim)]
        num_cores_to_use = max(cpu_count() - 5, 4)
        with Pool(processes=num_cores_to_use) as pool:
            Total_BE = pool.map(self.process_row, args)
        return Total_BE

def main():
    sim = 10000
    pd.options.display.float_format = '{:12.5e}'.format
    wsp = pd.read_csv("wsp_csv.csv", sep=";", decimal=",")
    dev = wsp.iloc[0, 0:59].to_list()
    sigma_j = wsp.iloc[1, 0:59].to_list()
    sd = wsp.iloc[2, 0:59].to_list()
    data_paid = pd.read_csv("data.csv", sep=";", decimal=",")
    data_paid = data_paid.iloc[:, 1:]
    model = StochasticModel(seed=202260011)
    result = model.stochastic_triangle_forward_test_szybki(data_paid, sigma_j, dev, sd, sim, 4232149669)
    print("Quantile 0.995:", np.quantile(result, 0.995))
    print("Quantile 0.996:", np.quantile(result, 0.996))
    print("Quantile 0.997:", np.quantile(result, 0.997))
    print("Quantile 0.998:", np.quantile(result, 0.998))
    print("Quantile 0.999:", np.quantile(result, 0.999))
    print("Mean:", np.mean(result))
    print("Difference (Quantile - Mean):", np.quantile(result, 0.995) - np.mean(result))
    pd_dev = pd.DataFrame({"BE": result})
    pd_dev.to_csv("BE_PCG.csv")
    plt.hist(result, bins=50, edgecolor='black')
    plt.xlabel('Wynik')
    plt.ylabel('Częstość')
    plt.title('Histogram wyników symulacji')
    plt.show()

if __name__ == "__main__":
    freeze_support()  # Potrzebne tylko na Windowsie w przypadku tworzenia wykonywalnych plików
    main()
