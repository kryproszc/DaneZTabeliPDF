#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <string.h>

#define MAX_EVENTS 10

int main() {
    int epoll_fd, pipe_fd[2];
    struct epoll_event event, events[MAX_EVENTS];
 
    if (pipe(pipe_fd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    // tworze epoolla
    epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }
 
    event.events = EPOLLIN;
    event.data.fd = pipe_fd[0];
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, pipe_fd[0], &event) == -1) {
        perror("epoll_ctl");
        exit(EXIT_FAILURE);
    }

    // wysylam dane do pipe
    const char *msg = "test epolla";
    if (write(pipe_fd[1], msg, strlen(msg)) == -1) {
        perror("write");
        exit(EXIT_FAILURE);
    }

    // Oczekiwanie na zdarzenia
    int n = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
    if (n == -1) {
        perror("epoll_wait");
        exit(EXIT_FAILURE);
    }

    // obsluguje zdarzenie
    for (int i = 0; i < n; i++) {
        if (events[i].events & EPOLLIN) {
            char buffer[100];
            ssize_t count = read(events[i].data.fd, buffer, sizeof(buffer) - 1);
            if (count == -1) {
                perror("read");
                exit(EXIT_FAILURE);
            }
            buffer[count] = '\0';
            printf("Odebrano: %s\n", buffer);
        }
    }

    close(pipe_fd[0]);
    close(pipe_fd[1]);
    close(epoll_fd);

    return 0;
}
