#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <unistd.h>

#include <algorithm>
#include <atomic>
#include <chrono>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <pqxx/pqxx>
#include <sstream>
#include <thread>
#include <vector>

#include "csvstream.hpp"
#include "json.hpp"

const int NUM_THREADS = 10;
const char *HOST = "127.0.0.1";

const char *PORT = "9741";
const char *PORT2 = "9742";
std::atomic<int> counterz(0);

std::vector<std::vector<std::string>> allStrings(NUM_THREADS);
std::vector<std::vector<std::string>> allStringsId(NUM_THREADS);

pqxx::connection c(
    "dbname=nominatim user=nominatim password=nominatim host=localhost "
    "port=5432");
pqxx::work txn(c);

std::map<std::tuple<std::string, std::string, int>, std::pair<int, std::string>>
    occurrences;

std::map<std::tuple<std::string, std::string, std::string>, int> wordCnt;

void addOccurrence(const std::string &city, const std::string &postcode,
                   int flag, int vecPos) {
  if (!city.empty() || !postcode.empty()) {
    auto &entry = occurrences[{city, postcode, flag}];

    entry.first++;

    entry.second += std::to_string(vecPos) + " ";
  }
}

struct Address {
  std::string lp;
  std::string ulica;
  std::string kodPocztowy;
  std::string miasto;
  std::string wojewodztwo;
  std::string kraj;
  std::string lot;
  std::string lat;
  int flaga1;
  int flaga2;
  std::string sklejone;
  std::string numerUmowy;
  std::string dataPoczatku;
  std::string dataKonca;
  std::string sumaUbezpieczenia;
  std::string odnowienia;
  std::string reasekuracjaO;
  std::string reasekuracjaF;
  std::string adresujedn;
};
std::vector<Address> dataToCSV;
std::vector<Address> flaga2;
std::vector<Address> flaga3;
std::vector<Address> flaga4;
std::vector<Address> flaga5;
std::vector<Address> flaga6;

const double PI = 3.14159265358979323846;
const double R = 6371.0;

std::string url_encode(const std::string &value) {
  std::ostringstream encoded;
  encoded.fill('0');
  encoded << std::nouppercase << std::hex;

  for (char c : value) {
    if (c == ';') {
      encoded << "%3B";
    } else if (!isalnum(static_cast<unsigned char>(c)) && c != '-' &&
               c != '_' && c != '.' && c != '~') {
      encoded << '%' << std::setw(2)
              << static_cast<int>(static_cast<unsigned char>(c));
    } else {
      encoded << c;
    }
  }

  return encoded.str();
}

int create_nonblocking_socket(const char *host, const char *port) {
  struct addrinfo hints, *res;
  int sockfd;

  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;

  if (getaddrinfo(host, port, &hints, &res) != 0) {
    perror("getaddrinfo");
    return -1;
  }

  sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  if (sockfd == -1) {
    perror("socket");
    freeaddrinfo(res);
    return -1;
  }

  int flags = fcntl(sockfd, F_GETFL, 0);
  if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == -1) {
    perror("fcntl");
    close(sockfd);
    freeaddrinfo(res);
    return -1;
  }

  if (connect(sockfd, res->ai_addr, res->ai_addrlen) == -1) {
    if (errno != EINPROGRESS) {
      perror("connect");
      close(sockfd);
      freeaddrinfo(res);
      return -1;
    }
  }

  freeaddrinfo(res);
  return sockfd;
}
std::vector<std::vector<Address>> all(NUM_THREADS);
std::vector<std::vector<Address>> all2(NUM_THREADS);
std::vector<std::vector<Address>> all3(NUM_THREADS);
std::vector<std::vector<Address>> all4(NUM_THREADS);

void add(const Address &pos, int &currentIndex) {
  all[currentIndex].push_back(pos);
  currentIndex = (currentIndex + 1) % all.size();
}
std::string removeUpToFirstSemicolon(const std::string &input) {
  size_t pos = input.find(';');

  if (pos != std::string::npos) {
    return input.substr(pos + 1);
  }

  return "";
}

void perform_requests4(int thread_id,
                       std::shared_ptr<std::vector<std::string>> &data) {
  int NUM_REQUESTS = all4[thread_id].size();

  int epoll_fd = epoll_create1(0);
  if (epoll_fd == -1) {
    perror("epoll_create1");
    exit(1);
  }
  int valuer = ++counterz;

  int sockfd;

  sockfd = create_nonblocking_socket(HOST, PORT);

  if (sockfd == -1) {
    exit(1);
  }

  epoll_event ev, events[NUM_REQUESTS];

  ev.events = EPOLLOUT | EPOLLET;
  ev.data.fd = sockfd;
  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &ev) == -1) {
    perror("epoll_ctl: EPOLLOUT");
    close(sockfd);
    exit(1);
  }

  int requests_sent = 0;
  bool keep_going = true;
  int id = 0;
  int lp = 0;

  while (keep_going) {
    int nfds = epoll_wait(epoll_fd, events, NUM_REQUESTS, -1);
    if (nfds == -1) {
      perror("epoll_wait");
      exit(1);
    }

    for (int n = 0; n < nfds; ++n) {
      if (events[n].events & EPOLLOUT && requests_sent < NUM_REQUESTS) {
        std::string address = url_encode(all4[thread_id][id++].sklejone);

        std::string request =
            "GET /search.php?q=" + address + "&format=json&limit=1" +
            " HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nConnection: "
            "keep-alive\r\n\r\n";
        ssize_t bytes_sent = send(sockfd, request.c_str(), request.length(), 0);
        if (bytes_sent == -1) {
          perror("send");
          keep_going = false;
          break;
        }
        requests_sent++;
        ev.events = EPOLLIN | EPOLLET;
        ev.data.fd = sockfd;
        if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
          perror("epoll_ctl: EPOLLIN");
          keep_going = false;
          break;
        }
      } else if (events[n].events & EPOLLIN) {
        char buffer[4096];
        std::string response;
        ssize_t bytes_read;
        while ((bytes_read = read(sockfd, buffer, sizeof(buffer))) > 0) {
          response.append(buffer, bytes_read);
        }

        if (bytes_read == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
          perror("read");
          keep_going = false;
        } else if (bytes_read == 0) {
          keep_going = false;
        } else {
          if (requests_sent < NUM_REQUESTS) {
            ev.events = EPOLLOUT | EPOLLET;
            ev.data.fd = sockfd;
            if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
              perror("epoll_ctl: EPOLLOUT");
              keep_going = false;
            }
          } else {
            keep_going = false;
          }
        }

        if (!response.empty()) {
          std::string http_response = response;

          std::string::size_type json_start = http_response.find('[');

          if (json_start != std::string::npos) {
            std::string json_str = http_response.substr(json_start);

            nlohmann::json j = nlohmann::json::parse(json_str);

            if (!j[0]["lat"].is_null()) {
              std::string lat = "" + std::string(j[0]["lat"]);
              std::string lon = "" + std::string(j[0]["lon"]);
              std::string name = "" + std::string(j[0]["display_name"]);
              all4[thread_id][lp].lat = lat;
              all4[thread_id][lp].lot = lon;
              all4[thread_id][lp].adresujedn = name;
              all4[thread_id][lp].flaga2 = 3;

              dataToCSV[std::stoi(all4[thread_id][lp].lp)] =
                  std::move(all4[thread_id][lp]);

            } else {
              all4[thread_id][lp].lat = "0";
              all4[thread_id][lp].lot = "0";
              all4[thread_id][lp].adresujedn = "Brak danych";
              all4[thread_id][lp].flaga2 = 3;

              dataToCSV[std::stoi(all4[thread_id][lp].lp)] =
                  std::move(all4[thread_id][lp]);
            }
            lp++;
          }
        }
      }
    }
  }

  close(sockfd);
  close(epoll_fd);
}

void perform_requests3(int thread_id,
                       std::shared_ptr<std::vector<std::string>> &data) {
  int NUM_REQUESTS = all3[thread_id].size();

  int epoll_fd = epoll_create1(0);
  if (epoll_fd == -1) {
    perror("epoll_create1");
    exit(1);
  }
  int valuer = ++counterz;

  int sockfd;

  sockfd = create_nonblocking_socket(HOST, PORT);

  if (sockfd == -1) {
    exit(1);
  }

  epoll_event ev, events[NUM_REQUESTS];

  ev.events = EPOLLOUT | EPOLLET;
  ev.data.fd = sockfd;
  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &ev) == -1) {
    perror("epoll_ctl: EPOLLOUT");
    close(sockfd);
    exit(1);
  }

  int requests_sent = 0;
  bool keep_going = true;
  int id = 0;
  int lp = 0;

  while (keep_going) {
    int nfds = epoll_wait(epoll_fd, events, NUM_REQUESTS, -1);
    if (nfds == -1) {
      perror("epoll_wait");
      exit(1);
    }

    for (int n = 0; n < nfds; ++n) {
      if (events[n].events & EPOLLOUT && requests_sent < NUM_REQUESTS) {
        std::string address = url_encode(all3[thread_id][id++].sklejone);

        std::string request =
            "GET /search.php?q=" + address + "&format=json&limit=1" +
            " HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nConnection: "
            "keep-alive\r\n\r\n";
        ssize_t bytes_sent = send(sockfd, request.c_str(), request.length(), 0);
        if (bytes_sent == -1) {
          perror("send");
          keep_going = false;
          break;
        }
        requests_sent++;
        ev.events = EPOLLIN | EPOLLET;
        ev.data.fd = sockfd;
        if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
          perror("epoll_ctl: EPOLLIN");
          keep_going = false;
          break;
        }
      } else if (events[n].events & EPOLLIN) {
        char buffer[4096];
        std::string response;
        ssize_t bytes_read;
        while ((bytes_read = read(sockfd, buffer, sizeof(buffer))) > 0) {
          response.append(buffer, bytes_read);
        }

        if (bytes_read == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
          perror("read");
          keep_going = false;
        } else if (bytes_read == 0) {
          keep_going = false;
        } else {
          if (requests_sent < NUM_REQUESTS) {
            ev.events = EPOLLOUT | EPOLLET;
            ev.data.fd = sockfd;
            if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
              perror("epoll_ctl: EPOLLOUT");
              keep_going = false;
            }
          } else {
            keep_going = false;
          }
        }

        if (!response.empty()) {
          std::string http_response = response;

          std::string::size_type json_start = http_response.find('[');

          if (json_start != std::string::npos) {
            std::string json_str = http_response.substr(json_start);

            nlohmann::json j = nlohmann::json::parse(json_str);

            if (!j[0]["lat"].is_null()) {
              std::string lat = "" + std::string(j[0]["lat"]);
              std::string lon = "" + std::string(j[0]["lon"]);
              std::string name = "" + std::string(j[0]["display_name"]);

              all3[thread_id][lp].adresujedn = name;
              all3[thread_id][lp].flaga2 = 2;

              if (all3[thread_id][lp].flaga1 == 2) {
                addOccurrence(all3[thread_id][lp].miasto,
                              all3[thread_id][lp].kodPocztowy, 2,
                              flaga2.size());
                flaga2.push_back(all3[thread_id][lp]);

                all3[thread_id].erase(all3[thread_id].begin() + lp);

                lp--;
                id--;
              } else if (all3[thread_id][lp].flaga1 == 6) {
                addOccurrence(all3[thread_id][lp].miasto,
                              all3[thread_id][lp].kodPocztowy, 6,
                              flaga6.size());

                flaga6.push_back(all3[thread_id][lp]);
                all3[thread_id].erase(all3[thread_id].begin() + lp);

                lp--;
                id--;

              } else {
                all3[thread_id][lp].lat = lat;
                all3[thread_id][lp].lot = lon;
                dataToCSV[std::stoi(all3[thread_id][lp].lp)] =
                    std::move(all3[thread_id][lp]);
              }
            } else {
              all3[thread_id][lp].sklejone =
                  removeUpToFirstSemicolon(all3[thread_id][lp].sklejone);

              all4[thread_id].push_back(all3[thread_id][lp]);

              all3[thread_id].erase(all3[thread_id].begin() + lp);

              lp--;
              id--;
            }
            lp++;
          }
        }
      }
    }
  }

  close(sockfd);
  close(epoll_fd);

  if (all4[thread_id].size() > 0) perform_requests4(thread_id, data);
}

void perform_requests2(int thread_id,
                       std::shared_ptr<std::vector<std::string>> &data) {
  (*data)[thread_id] +=
      "Dane z wątku2222 " + std::to_string(thread_id) + "\n\n";

  int NUM_REQUESTS = all2[thread_id].size();

  int epoll_fd = epoll_create1(0);
  if (epoll_fd == -1) {
    perror("epoll_create1");
    exit(1);
  }
  int valuer = ++counterz;

  int sockfd;

  sockfd = create_nonblocking_socket(HOST, PORT);

  if (sockfd == -1) {
    exit(1);
  }

  epoll_event ev, events[NUM_REQUESTS];

  ev.events = EPOLLOUT | EPOLLET;
  ev.data.fd = sockfd;
  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &ev) == -1) {
    perror("epoll_ctl: EPOLLOUT");
    close(sockfd);
    exit(1);
  }

  int requests_sent = 0;
  bool keep_going = true;
  int id = 0;
  int lp = 0;

  while (keep_going) {
    int nfds = epoll_wait(epoll_fd, events, NUM_REQUESTS, -1);
    if (nfds == -1) {
      perror("epoll_wait");
      exit(1);
    }

    for (int n = 0; n < nfds; ++n) {
      if (events[n].events & EPOLLOUT && requests_sent < NUM_REQUESTS) {
        std::string address = url_encode(all2[thread_id][id++].sklejone);

        std::string request =
            "GET /search.php?q=" + address + "&format=json&limit=1" +
            " HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nConnection: "
            "keep-alive\r\n\r\n";
        ssize_t bytes_sent = send(sockfd, request.c_str(), request.length(), 0);
        if (bytes_sent == -1) {
          perror("send");
          keep_going = false;
          break;
        }
        requests_sent++;
        ev.events = EPOLLIN | EPOLLET;
        ev.data.fd = sockfd;
        if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
          perror("epoll_ctl: EPOLLIN");
          keep_going = false;
          break;
        }
      } else if (events[n].events & EPOLLIN) {
        char buffer[4096];
        std::string response;
        ssize_t bytes_read;
        while ((bytes_read = read(sockfd, buffer, sizeof(buffer))) > 0) {
          response.append(buffer, bytes_read);
        }

        if (bytes_read == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
          perror("read");
          keep_going = false;
        } else if (bytes_read == 0) {
          keep_going = false;
        } else {
          if (requests_sent < NUM_REQUESTS) {
            ev.events = EPOLLOUT | EPOLLET;
            ev.data.fd = sockfd;
            if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
              perror("epoll_ctl: EPOLLOUT");
              keep_going = false;
            }
          } else {
            keep_going = false;
          }
        }

        if (!response.empty()) {
          std::string http_response = response;

          std::string::size_type json_start = http_response.find('[');

          if (json_start != std::string::npos) {
            std::string json_str = http_response.substr(json_start);

            nlohmann::json j = nlohmann::json::parse(json_str);

            if (!j[0]["lat"].is_null()) {
              std::string lat = "" + std::string(j[0]["lat"]);
              std::string lon = "" + std::string(j[0]["lon"]);
              std::string name = "" + std::string(j[0]["display_name"]);

              all2[thread_id][lp].adresujedn = name;
              all2[thread_id][lp].flaga2 = 1;

              if (all2[thread_id][lp].flaga1 == 2) {
                addOccurrence(all2[thread_id][lp].miasto,
                              all2[thread_id][lp].kodPocztowy, 2,
                              flaga2.size());

                flaga2.push_back(all2[thread_id][lp]);

                all2[thread_id].erase(all2[thread_id].begin() + lp);

                lp--;
                id--;
              } else if (all2[thread_id][lp].flaga1 == 3) {
                addOccurrence(all2[thread_id][lp].miasto,
                              all2[thread_id][lp].kodPocztowy, 3,
                              flaga3.size());

                flaga3.push_back(all2[thread_id][lp]);

                all2[thread_id].erase(all2[thread_id].begin() + lp);

                lp--;
                id--;
              } else if (all2[thread_id][lp].flaga1 == 6) {
                addOccurrence(all2[thread_id][lp].miasto,
                              all2[thread_id][lp].kodPocztowy, 6,
                              flaga6.size());

                flaga6.push_back(all2[thread_id][lp]);
                all2[thread_id].erase(all2[thread_id].begin() + lp);

                lp--;
                id--;

              } else {
                all2[thread_id][lp].lat = lat;
                all2[thread_id][lp].lot = lon;

                dataToCSV[std::stoi(all2[thread_id][lp].lp)] =
                    std::move(all2[thread_id][lp]);
              }
            } else {
              all2[thread_id][lp].sklejone =
                  removeUpToFirstSemicolon(all2[thread_id][lp].sklejone);

              all3[thread_id].push_back(all2[thread_id][lp]);

              all2[thread_id].erase(all2[thread_id].begin() + lp);

              lp--;
              id--;
            }
            lp++;
          }
        }
      }
    }
  }

  close(sockfd);
  close(epoll_fd);

  if (all3[thread_id].size() > 0) perform_requests3(thread_id, data);
}

void perform_requests(int thread_id,
                      std::shared_ptr<std::vector<std::string>> &data) {
  int NUM_REQUESTS = all[thread_id].size();

  int epoll_fd = epoll_create1(0);
  if (epoll_fd == -1) {
    perror("epoll_create1");
    exit(1);
  }
  int valuer = ++counterz;

  int sockfd;

  sockfd = create_nonblocking_socket(HOST, PORT);

  if (sockfd == -1) {
    exit(1);
  }

  epoll_event ev, events[NUM_REQUESTS];

  ev.events = EPOLLOUT | EPOLLET;
  ev.data.fd = sockfd;
  if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &ev) == -1) {
    perror("epoll_ctl: EPOLLOUT");
    close(sockfd);
    exit(1);
  }

  int requests_sent = 0;
  bool keep_going = true;
  int id = 0;
  int lp = 0;

  while (keep_going) {
    int nfds = epoll_wait(epoll_fd, events, NUM_REQUESTS, -1);
    if (nfds == -1) {
      perror("epoll_wait");
      exit(1);
    }

    for (int n = 0; n < nfds; ++n) {
      if (events[n].events & EPOLLOUT && requests_sent < NUM_REQUESTS) {
        std::string address = url_encode(all[thread_id][id++].sklejone);

        std::string request =
            "GET /search.php?q=" + address + "&format=json&limit=1" +
            " HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nConnection: "
            "keep-alive\r\n\r\n";
        ssize_t bytes_sent = send(sockfd, request.c_str(), request.length(), 0);
        if (bytes_sent == -1) {
          perror("send");
          keep_going = false;
          break;
        }
        requests_sent++;
        ev.events = EPOLLIN | EPOLLET;
        ev.data.fd = sockfd;
        if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
          perror("epoll_ctl: EPOLLIN");
          keep_going = false;
          break;
        }
      } else if (events[n].events & EPOLLIN) {
        char buffer[4096];
        std::string response;
        ssize_t bytes_read;
        while ((bytes_read = read(sockfd, buffer, sizeof(buffer))) > 0) {
          response.append(buffer, bytes_read);
        }

        if (bytes_read == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
          perror("read");
          keep_going = false;
        } else if (bytes_read == 0) {
          keep_going = false;
        } else {
          if (requests_sent < NUM_REQUESTS) {
            ev.events = EPOLLOUT | EPOLLET;
            ev.data.fd = sockfd;
            if (epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &ev) == -1) {
              perror("epoll_ctl: EPOLLOUT");
              keep_going = false;
            }
          } else {
            keep_going = false;
          }
        }

        if (!response.empty()) {
          std::string http_response = response;

          std::string::size_type json_start = http_response.find('[');

          if (json_start != std::string::npos) {
            std::string json_str = http_response.substr(json_start);

            nlohmann::json j = nlohmann::json::parse(json_str);

            if (!j[0]["lat"].is_null()) {
              std::string lat = "" + std::string(j[0]["lat"]);
              std::string lon = "" + std::string(j[0]["lon"]);
              std::string name = "" + std::string(j[0]["display_name"]);

              all[thread_id][lp].adresujedn = name;
              all[thread_id][lp].flaga2 = 0;

              if (all[thread_id][lp].flaga1 == 4) {
                addOccurrence(all[thread_id][lp].miasto,
                              all[thread_id][lp].kodPocztowy, 4, flaga4.size());
                flaga4.push_back(all[thread_id][lp]);
                all[thread_id].erase(all[thread_id].begin() + lp);

                lp--;
                id--;

              } else if (all[thread_id][lp].flaga1 == 5) {
                addOccurrence(all[thread_id][lp].miasto,
                              all[thread_id][lp].kodPocztowy, 5, flaga5.size());
                flaga5.push_back(all[thread_id][lp]);
                all[thread_id].erase(all[thread_id].begin() + lp);

                lp--;
                id--;

              } else {
                all[thread_id][lp].lat = lat;
                all[thread_id][lp].lot = lon;
                dataToCSV[std::stoi(all[thread_id][lp].lp)] =
                    std::move(all[thread_id][lp]);
              }

            } else {
              all[thread_id][lp].sklejone =
                  removeUpToFirstSemicolon(all[thread_id][lp].sklejone);

              all2[thread_id].push_back(all[thread_id][lp]);

              all[thread_id].erase(all[thread_id].begin() + lp);

              lp--;
              id--;
            }
            lp++;
          }
        }
      }
    }
  }

  close(sockfd);
  close(epoll_fd);

  if (all2[thread_id].size() > 0) perform_requests2(thread_id, data);
}

std::string removeAfterSlash(std::string address) {
  size_t pos;

  pos = address.find('/');
  if (pos != std::string::npos) {
    address = address.substr(0, pos);
  }

  return address;
}

std::string removeWord(const std::string &input,
                       const std::string &wordToRemove) {
  std::istringstream stream(input);
  std::string word;
  std::string result;

  while (stream >> word) {
    if (word != wordToRemove) {
      result += word + " ";
    }
  }

  if (!result.empty()) {
    result.pop_back();
  }

  return result;
}

std::string removeWordsWithDot(const std::string &input) {
  std::istringstream stream(input);
  std::string word;
  std::string result;

  while (stream >> word) {
    if (word.find('.') == std::string::npos) {
      result += word + " ";
    }
  }

  if (!result.empty()) {
    result.pop_back();
  }

  return result;
}

bool containsWordIgnoreCase(const std::string &text, const std::string &word) {
  std::string lowerText = text;
  std::string lowerWord = word;

  std::transform(lowerText.begin(), lowerText.end(), lowerText.begin(),
                 ::tolower);
  std::transform(lowerWord.begin(), lowerWord.end(), lowerWord.begin(),
                 ::tolower);

  return lowerText.find(lowerWord) != std::string::npos;
}

void addStringId(std::vector<std::vector<std::string>> &allStringsId,
                 const std::string &str, int &currentIndex) {
  allStringsId[currentIndex].push_back(str);
  currentIndex = (currentIndex + 1) % allStringsId.size();
}

void addString(std::vector<std::vector<std::string>> &allStrings,
               const std::string &str, int &currentIndex) {
  allStrings[currentIndex].push_back(str);
  currentIndex = (currentIndex + 1) % allStrings.size();
}

bool hasNumber(const std::string &str) {
  return str.find_first_of("0123456789") != std::string::npos;
}

std::string removeSpecificTitles(const std::string &str) {
  std::string result = str;
  std::vector<std::string> titles = {"doktora"};

  for (const auto &title : titles) {
    size_t pos = result.find(title);
    while (pos != std::string::npos) {
      result.erase(pos, title.length());
      pos = result.find(title);
    }
  }

  return result;
}

void wypiszAdresy(const std::vector<Address> &addresses,
                  const std::string &nazwaWektora) {
  std::cout << "Wektor: " << nazwaWektora << std::endl;
  for (const auto &address : addresses) {
    std::cout << "Kod pocztowy: " << address.kodPocztowy
              << ", Miasto: " << address.miasto
              << ", Flaga1: " << address.flaga1 << std::endl;
  }
  std::cout << std::endl;
}

void saveToCSV(const std::vector<Address> &dataToCSV,
               const std::string &filename) {
  std::ofstream file(filename);

  if (!file.is_open()) {
    std::cerr << "Nie można otworzyć pliku do zapisu!" << std::endl;
    return;
  }

  file << "Lp;NumerUmowy;DataPoczatku;DataKonca;SumaUbezpieczenia;Odnowienia;"
          "Ulica;KodPocztowy;Miasto;Wojewodztwo;Kraj;ReasekuracjaO;"
          "ReasekuracjaF;Szerokosc;Dlugosc;AdresUjednolicony;Flaga_1;Flaga_2\n";

  for (size_t i = 1; i < dataToCSV.size(); ++i) {
    const auto &address = dataToCSV[i];
    file << address.lp << ";" << address.numerUmowy << ";"
         << address.dataPoczatku << ";" << address.dataKonca << ";"
         << address.sumaUbezpieczenia << ";" << address.odnowienia << ";"
         << address.ulica << ";" << address.kodPocztowy << ";" << address.miasto
         << ";" << address.wojewodztwo << ";" << address.kraj << ";"
         << address.reasekuracjaO << ";" << address.reasekuracjaF << ";"
         << address.lat << ";" << address.lot << ";" << address.adresujedn
         << ";" << address.flaga1 << ";" << address.flaga2 << ";" << "\n";
  }

  file.close();
}

int pobierzLiczbe(const std::string &ciag, int indeks) {
  std::istringstream iss(ciag);
  std::string liczba;
  int licznik = 0;

  while (iss >> liczba) {
    if (licznik == indeks) {
      return std::stoi(liczba);
    }
    licznik++;
  }

  throw std::out_of_range("Nie znaleziono liczby o podanym indeksie.");
}

int main() {
  std::cout << "Polaczony z " << c.dbname() << '\n';

  int currentIndex = 0;
  int currentIndexId = 0;

  csvstream csvin("test.csv");

  std::vector<std::pair<std::string, std::string>> row;

  auto start = std::chrono::high_resolution_clock::now();

  int rows_cnt = 1;
  while (csvin >> row) {
    std::string sklejone = "";
    std::string lp = row[0].second;
    std::string numerUmowy = row[1].second;
    std::string dataPoczatku = row[2].second;
    std::string dataKonca = row[3].second;
    std::string sumaUbezpieczenia = row[4].second;
    std::string odnowienia = row[5].second;
    std::string ulica = row[6].second;
    std::string kodPocztowy = row[7].second;
    std::string miasto = row[8].second;
    std::string wojewodztwo = row[9].second;
    std::string kraj = row[10].second;
    std::string reasekuracjaO = row[11].second;
    std::string reasekuracjaF = row[12].second;

    int flaga1 = -1;
    int flaga2 = -1;

    ulica = removeWord(ulica, "nr");
    ulica = removeAfterSlash(ulica);

    if (ulica != "" && kodPocztowy != "" && miasto != "" && wojewodztwo != "" &&
        kraj != "" && ulica == miasto) {
      flaga1 = 1;
      sklejone = ulica + ";" + kodPocztowy + ";" + wojewodztwo + ";" + kraj;
    } else if (ulica != "" && kodPocztowy != "" && miasto != "" &&
               wojewodztwo != "" && kraj != "" &&
               ulica.find(miasto) != std::string::npos) {
      flaga1 = 1;
      sklejone = ulica + ";" + kodPocztowy + ";" + wojewodztwo + ";" + kraj;
    } else if (ulica != "" && kodPocztowy != "" && miasto == "" &&
               wojewodztwo != "" && kraj != "") {
      flaga1 = 6;
      sklejone = ulica + ";" + kodPocztowy + ";" + wojewodztwo + ";" + kraj;
    } else if (ulica == "" && miasto == "" && wojewodztwo == "" && kraj == "" &&
               kodPocztowy != "") {
      flaga1 = 4;
      sklejone = kodPocztowy;
    } else if (ulica == "" && miasto == "" && wojewodztwo == "" && kraj != "" &&
               kodPocztowy == "") {
      flaga1 = 5;
      sklejone = kraj;
    } else if (ulica == "" && miasto != "" && wojewodztwo != "" && kraj != "" &&
               kodPocztowy != "") {
      sklejone = kodPocztowy + ";" + miasto + ";" + wojewodztwo + ";" + kraj;
      flaga1 = 2;
    } else if (ulica == "" && miasto != "" && wojewodztwo != "" && kraj != "" &&
               kodPocztowy == "") {
      sklejone = miasto + ";" + wojewodztwo + ";" + kraj;
      flaga1 = 3;
    } else {
      sklejone = ulica + ";" + kodPocztowy + ";" + miasto + ";" + wojewodztwo +
                 ";" + kraj;
      flaga1 = 0;
    }

    add(Address{lp, ulica, kodPocztowy, miasto, wojewodztwo, kraj,
                "brak danych", "brak danych", flaga1, flaga2, sklejone,
                numerUmowy, dataPoczatku, dataKonca, sumaUbezpieczenia,
                odnowienia, reasekuracjaO, reasekuracjaF, ""},
        currentIndex);

    rows_cnt++;
  }
  dataToCSV.resize(rows_cnt);
  for (int i = 0; i < rows_cnt; ++i) {
    dataToCSV[i] = {};
  }
  std::vector<std::thread> threads;
  auto data = std::make_shared<std::vector<std::string>>(NUM_THREADS);

  for (int i = 0; i < NUM_THREADS; i++) {
    threads.emplace_back(perform_requests, i, std::ref(data));
  }

  for (auto &t : threads) {
    t.join();
  }

  std::stringstream query;

  bool first = true;

  for (const auto &entry : occurrences) {
    const auto &key = entry.first;
    const auto &value = entry.second;

    const std::string &city = std::get<0>(key);
    const std::string &postcode = std::get<1>(key);
    int flag = std::get<2>(key);
    int count = value.first;
    std::string vecPos = value.second;

    if (count > 0 && (!city.empty() || !postcode.empty())) {
      if (!first) {
        query << "UNION ALL\n";
      }

      query << "(\n"
            << "    SELECT \n"
            << "        " << flag << " AS Flag,\n"
            << "        " << '\'' << vecPos << '\'' << " AS VecPos,\n"
            << "        address,\n"
            << "        ST_Y(ST_Centroid(centroid)) AS lat,\n"
            << "        ST_X(ST_Centroid(centroid)) AS lon\n"
            << "    FROM \n"
            << "        placex\n"
            << "    WHERE \n";

      bool hasCondition = false;
      if (!postcode.empty()) {
        query << "        address -> 'postcode' ILIKE '" << postcode << "'\n";
        hasCondition = true;
      }
      if (!city.empty()) {
        if (hasCondition) {
          query << "        AND ";
        }
        query << "address -> 'city' ILIKE '" << city << "'\n";
        hasCondition = true;
      }

      if (hasCondition) {
        query << "        AND ";
      }
      query << "address -> 'housenumber' IS NOT NULL AND address -> "
               "'housenumber' != ''\n";

      query << "    LIMIT " << count << "\n"
            << ")\n";

      first = false;
    }
  }
  //std::cout<<query.str()<<std::endl;
  pqxx::result r = txn.exec(query);

  for (const auto &row : r) {
    std::string city, street, postcode, housenumber, place;

    size_t pos = 0;

    std::string input = row["address"].c_str();

    while (pos != std::string::npos) {
      size_t key_start = input.find('"', pos);
      if (key_start == std::string::npos) break;
      size_t key_end = input.find('"', key_start + 1);
      if (key_end == std::string::npos) break;

      std::string key = input.substr(key_start + 1, key_end - key_start - 1);

      size_t value_start = input.find('"', key_end + 1);
      if (value_start == std::string::npos) break;
      size_t value_end = input.find('"', value_start + 1);
      if (value_end == std::string::npos) break;

      std::string value =
          input.substr(value_start + 1, value_end - value_start - 1);

      if (key == "city") {
        city = value;
      } else if (key == "street") {
        street = value;
      } else if (key == "postcode") {
        postcode = value;
      } else if (key == "housenumber") {
        housenumber = value;
      } else if (key == "place") {
        place = value;
      }

      pos = value_end + 1;
    }

    if (city != "") city = place;

    int flag = row["Flag"].as<int>();
    std::string vecPositions = row["VecPos"].c_str();
    double lat = row["lat"].as<double>();
    double lon = row["lon"].as<double>();

    wordCnt[{vecPositions, city, postcode}] += 1;
    int liczba = pobierzLiczbe(vecPositions,
                               wordCnt[{vecPositions, city, postcode}] - 1);

    if (flag == 2) {
      if (flaga2.size() > liczba) {
        flaga2[liczba].miasto = city;
        flaga2[liczba].kodPocztowy = postcode;
        flaga2[liczba].ulica = street + " " + housenumber;
        flaga2[liczba].lat = std::to_string(lat);
        flaga2[liczba].lot = std::to_string(lon);
      }
    } else if (flag == 3) {
      if (flaga3.size() > liczba) {
        flaga3[liczba].miasto = city;
        flaga3[liczba].kodPocztowy = postcode;
        flaga3[liczba].ulica = street + " " + housenumber;
        flaga3[liczba].lat = std::to_string(lat);
        flaga3[liczba].lot = std::to_string(lon);
      }
    } else if (flag == 4) {
      if (flaga4.size() > liczba) {
        flaga4[liczba].miasto = city;
        flaga4[liczba].kodPocztowy = postcode;
        flaga4[liczba].ulica = street + " " + housenumber;
        flaga4[liczba].lat = std::to_string(lat);
        ;
        flaga4[liczba].lot = std::to_string(lon);
        ;
      }

    } else if (flag == 5) {
      if (flaga5.size() > liczba) {
        flaga5[liczba].miasto = city;
        flaga5[liczba].kodPocztowy = postcode;
        flaga5[liczba].ulica = street + " " + housenumber;
        flaga5[liczba].lat = std::to_string(lat);
        ;
        flaga5[liczba].lot = std::to_string(lon);
        ;
      }
    } else if (flag == 6) {
      if (flaga6.size() > liczba) {
        flaga6[liczba].miasto = city;
        flaga6[liczba].kodPocztowy = postcode;
        flaga6[liczba].ulica = street + " " + housenumber;
        flaga6[liczba].lat = std::to_string(lat);
        ;
        flaga6[liczba].lot = std::to_string(lon);
        ;
      }
    }
  }
    std::cout << "Rozmiar flaga2: " << flaga2.size() << std::endl;
    std::cout << "Rozmiar flaga3: " << flaga3.size() << std::endl;
    std::cout << "Rozmiar flaga4: " << flaga4.size() << std::endl;
    std::cout << "Rozmiar flaga5: " << flaga5.size() << std::endl;
    std::cout << "Rozmiar flaga6: " << flaga6.size() << std::endl;

  for (auto &adres : flaga2) {
    int index = std::stoi(adres.lp);
    dataToCSV[index] = std::move(adres);
  }

  for (auto &adres : flaga3) {
    int index = std::stoi(adres.lp);
    dataToCSV[index] = std::move(adres);
  }

  for (auto &adres : flaga4) {
    int index = std::stoi(adres.lp);

    dataToCSV[index] = std::move(adres);
  }

  for (auto &adres : flaga5) {
    int index = std::stoi(adres.lp);

    dataToCSV[index] = std::move(adres);
  }

  for (auto &adres : flaga6) {
    int index = std::stoi(adres.lp);

    dataToCSV[index] = std::move(adres);
  }

  saveToCSV(dataToCSV, "geocoding.csv");

  auto end = std::chrono::high_resolution_clock::now();
  std::chrono::duration<double> duration = end - start;
  std::cout << "Czas : " << duration.count() << " sekund\n";

  return 0;
}
