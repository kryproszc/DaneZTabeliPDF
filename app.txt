Lp.	Nr_umowy	Data poczatku okresu ubezpieczenia	Data konca okresu ubezpieczenia	SU_v_PML	Odnow	Adres_Ulica_i_numer	Adres_Kod_pocztowy	Adres_Miasto	Adres_Wojewodztwo	Adres_Kraj	ReasekuracjaO	ReasekuracjaF



Lp	NumerUmowy	DataPoczatku	DataKonca	SumaUbezpieczenia	Odnowienia	Ulica	KodPocztowy	Miasto	Wojewodztwo	Kraj	ReasekuracjaO	ReasekuracjaF	Szerokosc	Dlugosc	AdresUjednolicony	Flaga_1	Flaga_2

install.packages('lwgeom')
library(httr)
library(jsonlite) 
library(readxl)
library(httr)
library(jsonlite)
library(ggplot2)
library(sf)
library(dplyr)
library('openxlsx')
library(lwgeom)
# Funkcja przyjmujÄ…ca ramkÄ™ danych z kodami pocztowymi i liczbÄ… budynkĂłw
get_coordinates_by_postcode <- function(data) {
  results <- data.frame(latitude = numeric(0), longitude = numeric(0), ilosc = numeric(0))
  
  for (i in 1:nrow(data)) {
    postcode <- data$kody[i]
    ilosc <- data$ilosc[i]

    
    url <- "http://dft-everace:8080/search.php"
    
    params <- list(q = postcode)
    
    response <- GET(url, query = params)
    
    if (status_code(response) == 200) {
      content_text <- content(response, "text", encoding = "UTF-8")
            response_json <- fromJSON(content_text, flatten = TRUE)
      
      
      if (!is.null(response_json$lat) && !is.null(response_json$lon)) {
        result_row <- data.frame(
          latitude = response_json$lat,
          longitude = response_json$lon,
          ilosc = ilosc
        )
        
        
        results <- rbind(results, result_row)
      } else {
        warning(paste("Brak danych geograficznych dla kodu:", postcode))
      }
    } else {
      warning(paste("BĹ‚Ä…d podczas zapytania dla kodu:", postcode, " - Kod odpowiedzi:", status_code(response)))
    }
  }
  
 
  if (nrow(results) == 0) {
    stop("Brak danych geograficznych dla podanych kodĂłw pocztowych.")
  }
  
  return(results)
}



###
data_input<-read.csv2("I:/WOM/Sprawy_bieżące/Model ryzyka pożaru/Model YE2023/2_dane od ZU/3_standaryzacja/wyniki/23 SALTUS TUW/standaryzacja v3/SALTUS TUW Ubezpieczone obiekty.csv",
                      sep=";",dec=".")

df_kody<-as.data.frame(table(data_input$Adres.ubezpieczonego.obiektu...Kod.pocztowy))
colnames(df_kody)<-c("kody","ilosc")


input_data <- data.frame(
  kody = c("00-001", "00-002", "00-003"),
  ilosc = c(20, 35, 50)
)
coordinates <- get_coordinates_by_postcode(input_data)

################################################################################################################

polska <- st_read("gminy/gminy.shp")  

print("Struktura wczytanych danych:")
print(st_geometry_type(polska))  
print(st_crs(polska))            

polska <- st_buffer(polska, 0)

if (any(!st_is_valid(polska))) {
  print(" Usuwanie nieprawidĹ‚owych geometrii...")
  polska <- polska[st_is_valid(polska), ]  
}

polska <- st_simplify(polska, dTolerance = 0.001)

print(paste("Liczba geometrii (gmin) po uproszczeniu:", nrow(polska)))


### program rysujacy



coordinates <- data.frame(
  latitude = c(52.22985, 50.06143, 51.10789),  
  longitude = c(21.00652, 19.93884, 17.03854), 
  ilosc = c(20, 35, 50)  
)

punkty_sf <- st_as_sf(coordinates, coords = c("longitude", "latitude"), crs = 4326)

znalezione_gminy <- list()


for (i in 1:nrow(punkty_sf)) {
  punkt <- punkty_sf[i, ]
  gmina <- polska[st_contains(polska, punkt, sparse = FALSE), ]
  
  if (nrow(gmina) > 0) {
    gmina$ilosc <- coordinates$ilosc[i]  
    znalezione_gminy[[i]] <- gmina  #
  }
}

wszystkie_gminy_sf <- do.call(rbind, znalezione_gminy)

ggplot() +
  geom_sf(data = polska, fill = "lightgray", color = "black") +  
  geom_sf(data = wszystkie_gminy_sf, aes(fill = ilosc), color = "black", size = 0.5) +  
  scale_fill_gradient(low = "lightyellow", high = "red", name = "Liczba budynków") +  
  theme_minimal() +
  labs(title = "Zaznaczenie gmin na mapie Polski na podstawie współrzędnych",
       subtitle = "Kolor i wielkość zależne od liczby budynków") +
  coord_sf()



#########################################################################
# test

library(ggplot2)
library(sf)
library(dplyr)

# Wczytanie granic Polski z pliku SHP (upewnij się, że podajesz właściwą ścieżkę do pliku)
polska <- st_read("gminy/gminy.shp")  # Podaj poprawną ścieżkę do pliku SHP z granicami gmin Polski

# Naprawa geometrii (opcjonalnie, jeśli występują problemy)
polska <- st_buffer(polska, 0)

# Przekształcenie układu współrzędnych granic gmin na WGS 84 (EPSG:4326)
polska <- st_transform(polska, crs = 4326)

# Przykładowa ramka danych zawierająca współrzędne i liczbę budynków w danym kodzie pocztowym
# Tutaj można dodać więcej wierszy z danymi o różnych kodach pocztowych
coordinates <- data.frame(
  latitude = c(52.22985, 50.06143, 51.10789),  # Szerokość geograficzna
  longitude = c(21.00652, 19.93884, 17.03854), # Długość geograficzna
  ilosc = c(20, 35, 50)  # Liczba budynków w danym kodzie pocztowym
)

# Konwersja ramki danych do obiektu przestrzennego (sf)
punkty_sf <- st_as_sf(coordinates, coords = c("longitude", "latitude"), crs = 4326)

# Lista do przechowywania gmin zawierających podane współrzędne
znalezione_gminy <- list()

# Iterowanie przez każdy punkt i znajdowanie gminy, która go zawiera
for (i in 1:nrow(punkty_sf)) {
  punkt <- punkty_sf[i, ]
  gmina <- polska[st_contains(polska, punkt, sparse = FALSE), ]
  
  if (nrow(gmina) > 0) {
    gmina$ilosc <- coordinates$ilosc[i]  # Dodajemy informację o liczbie budynków do gminy
    znalezione_gminy[[i]] <- gmina  # Przechowujemy gminę w liście
  }
}

# Połączenie wszystkich znalezionych gmin w jedną ramkę danych
wszystkie_gminy_sf <- do.call(rbind, znalezione_gminy)

# Rysowanie mapy Polski z zaznaczeniem wszystkich gmin i punktów
ggplot() +
  geom_sf(data = polska, fill = "lightgray", color = "black") +  # Rysowanie wszystkich granic gmin
  geom_sf(data = wszystkie_gminy_sf, aes(fill = ilosc), color = "black", size = 0.5) +  # Zaznaczenie znalezionych gmin, wypełnienie według liczby budynków
  scale_fill_gradient(low = "lightyellow", high = "red", name = "Liczba budynków") +  # Gradient kolorów dla liczby budynków
  theme_minimal() +
  labs(title = "Zaznaczenie gmin na mapie Polski na podstawie współrzędnych",
       subtitle = "Kolor i wielkość zależne od liczby budynków") +
  coord_sf()
