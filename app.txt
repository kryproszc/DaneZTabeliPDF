import numpy as np
import pandas as pd

class PCG_XSH_RR:
    def __init__(self, seed=42, increment=0xda3e39cb94b95bdb):
        self.state = seed
        self.increment = increment | 1  # Ensure the increment is odd

    def pcg32(self):
        oldstate = self.state
        # Advance internal state using linear congruential formula
        self.state = (oldstate * 6364136223846793005 + self.increment) & ((1 << 64) - 1)
        # Calculate output function (XSH RR), uses old state for max ILP
        xorshifted = ((oldstate >> 18) ^ oldstate) >> 27
        rot = oldstate >> 59
        return (xorshifted >> rot) | (xorshifted << ((-rot) & 31)) & ((1 << 32) - 1)

    def random(self):
        return self.pcg32() / float(1 << 32)

class RandomDistributionsZiggurat:
    def __init__(self, seed=42, increment=0xda3e39cb94b95bdb):
        self.pcg = PCG_XSH_RR(seed=seed, increment=increment)
        self.setup_ziggurat()

    def setup_ziggurat(self):
        self.R = 3.442620  # Right tail boundary for the normal distribution
        self.n = 256
        self.w = [0.0] * self.n
        self.f = [0.0] * self.n
        self.kn = [0] * self.n

        m1 = 2147483648.0
        dn = self.R
        tn = self.R
        q = 9.91256303526217e-3

        self.kn[0] = int((dn / q) * m1)
        self.kn[1] = 0

        self.w[0] = q / m1
        self.w[255] = dn / m1

        self.f[0] = 1.0
        self.f[255] = np.exp(-0.5 * dn * dn)

        for i in range(1, 255):
            dn = np.sqrt(-2.0 * np.log(self.f[i-1]))
            self.kn[i] = int((dn / self.R) * m1)
            self.w[i] = dn / m1
            self.f[i] = np.exp(-0.5 * dn * dn)

    def normal(self, mean=0.0, std_dev=1.0, size=1):
        samples = []
        while len(samples) < size:
            u = self.pcg.random()
            i = int(u * 256)
            sign = 1 if (u * 256 - i) < 0.5 else -1
            x = self.pcg.pcg32() * self.w[i]
            if abs(x) < self.f[i]:
                samples.append(mean + sign * x * std_dev)
            else:
                while True:
                    y = -np.log(self.pcg.random())
                    if y + y >= x * x:
                        break
                samples.append(mean + sign * (self.kn[i] / 2147483648.0) * std_dev)
        return np.array(samples[:size])

# Example usage:
random_gen_ziggurat = RandomDistributionsZiggurat(seed=42, increment=0xda3e39cb94b95bdb)
normal_samples_ziggurat = random_gen_ziggurat.normal(mean=0.0, std_dev=1.0, size=10)

samples_df = pd.DataFrame({
    "Ziggurat": normal_samples_ziggurat
})

samples_df
