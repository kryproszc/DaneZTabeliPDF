import numpy as np
import pandas as pd
from multiprocessing import Pool

def process_row(args):
    row, mu, sigma, mm, data_paid_copy, Ultimate_Param_ReservingRisk = args
    m_i, sigma_i = mu.iloc[row, :], sigma.iloc[row, :]
    for j in range(len(m_i)):
        max_ind_row = np.max([0, mm - j - 1])
        for i in range(max_ind_row, mm):
            VAR_i_j = (sigma_i[j]) / (data_paid_copy.iloc[i, j])
            lmean_i_j = np.log((m_i[j]) ** 2 / (np.sqrt((m_i[j]) ** 2 + VAR_i_j)))
            lstdev_i_j = np.log(1 + ((VAR_i_j) / ((m_i[j]) ** 2)))
            CL_i_j = np.random.lognormal(lmean_i_j, lstdev_i_j, size=1)
            data_paid_copy.iloc[i, j + 1] = data_paid_copy.iloc[i, j] * CL_i_j[0]

    Ultimate = data_paid_copy.iloc[:, data_paid_copy.columns[-1] - 1].to_list()
    BE = np.sum(Ultimate) - np.sum(Ultimate_Param_ReservingRisk)
    return BE

def random_stochastic_parameters(sigma_j, dev, sd, dimension):
    stochastic_sigma = pd.DataFrame(data=0, columns=np.arange(0, dimension[3], 1),
                                    index=np.arange(0, dimension[2], 1))
    mu_j = pd.DataFrame(data=0, columns=np.arange(0, dimension[3], 1), 
                        index=np.arange(0, dimension[2], 1))
    for j in range(0, dimension[3]):
        np.random.seed(10)
        st_swobody = np.max([1, dimension[0] - j - 2])
        chi = np.random.chisquare(st_swobody, size=dimension[2])
        stochastic_sigma.iloc[:, j] = (chi * sigma_j[j]) / st_swobody
        np.random.seed(10)
        mu_j.iloc[:, j] = np.random.normal(dev[j], sd[j], size=dimension[2])
    return [mu_j, stochastic_sigma]

def stochastic_triangle_forward_test_szybki(data_paid, sigma_j, dev, sd, sim, Ultimate_Param_ReservingRisk):
    mm, nn = data_paid.shape[0], data_paid.shape[1]
    dimension = [mm, nn, sim, len(dev)]
    Total_BE = []

    mu, sigma = random_stochastic_parameters(sigma_j, dev, sd, dimension)
    data_paid_copy = data_paid.copy()
    data_paid_copy_reRe = data_paid.copy()
    data_paid_copy_reRe[mm + 1] = np.nan

    if len(dev) > mm:
        for k in range(mm + 1, len(dev) + 2):
            data_paid_copy[k] = np.nan

    # Przygotowanie argumentów do funkcji równoległej
    args = [(row, mu, sigma, mm, data_paid_copy.copy(), Ultimate_Param_ReservingRisk) for row in range(0, sim)]

    # Określenie liczby rdzeni do użycia
    num_cores_to_use = 4  # na przykład 4 rdzenie

    # Użycie Pool do równoległego przetwarzania
    with Pool(processes=num_cores_to_use) as pool:
        Total_BE = pool.map(process_row, args)

    return Total_BE

# Przykładowe użycie
# data_paid = pd.DataFrame(...)  # Wprowadź swoje dane
# sigma_j = np.array(...)  # Wprowadź swoje dane
# dev = np.array(...)  # Wprowadź swoje dane
# sd = np.array(...)  # Wprowadź swoje dane
# sim = 1000  # Liczba symulacji
# Ultimate_Param_ReservingRisk = np.array(...)  # Wprowadź swoje dane

# result = stochastic_triangle_forward_test_szybki(data_paid, sigma_j, dev, sd, sim, Ultimate_Param_ReservingRisk)
