void processBudynki(const ......
 dataPoczatku = row["DataPoczatku"];
                std::string dataKonca = row["DataKonca"];
                int reasekuracjaf = 9999;
                try
                {
                    reasekuracjaf = std::stoi(row["ReasekuracjaF"]);
                }
                catch (const std::invalid_argument &e)
                {
                    reasekuracjaf = 9999;
                }
                if (odnowienia == 1)
                {
                    std::string StartlastFour = dataPoczatku.substr(dataPoczatku.length() - 4);
                    std::string EndlastFour = dataKonca.substr(dataKonca.length() - 4);
    
                    // konwersja na int
                    int StartYearnum = std::stoi(StartlastFour);
                    int EndYearnum = std::stoi(EndlastFour);

                    std::vector<std::vector<long double>> odnowienia_vec_data = read_odnowienia(filename[i]);
                    int policy_end_year_cop = calc_odnowienia(EndYearnum, odnowienia_vec_data, std::stoi(row["Odnowienia"]), std::stod(row["SumaUbezpieczenia"]));
                    dataKonca = dataKonca.replace(dataKonca.length() - 4, 4, std::to_string(policy_end_year_cop)); // zastąpienie ostatnich 4 znaków

                }

                get_dates_within_year(dataPoczatku, dataKonca, std::stoi(year));
                processRow(
                    dataPoczatku,
                    dataKonca,
                    std::stoi(row["WojUjednolicone"]),
                    std::stod(row["Szerokosc"]),
                    std::stod(row["Dlugosc"]),
                    reasekuracjaf,
                    std::stod(row["SumaUbezpieczenia"]),
                    id_ubezp);
            }
        }
        catch (const std::invalid_argument &e)
        {
            std::cerr << "Error: Invalid argument for stoi or stod conversion 1." << std::endl;
        }
    }
}



int calc_odnowienia(int polic_end_year,
                    std::vector<std::vector<long double>> odnowienia_vec_data,
                    int odnowienia_exponsure,
                    double sum_ub)
{
    int ind_pom = 0;
    int policy_end_year_cop;

    long double prob_unif = randZeroToOne(0, 1);
    long double find_prob_odn = find_prob_odnowienie(odnowienia_vec_data,
                                                     odnowienia_exponsure,
                                                     sum_ub);
    if (prob_unif <= find_prob_odn)
    {
        ind_pom += 1;
        policy_end_year_cop = polic_end_year + 1;
    }
    else
    {
        policy_end_year_cop = polic_end_year;
    }
    return (policy_end_year_cop);
}


long double find_prob_odnowienie(std::vector<std::vector<long double>> odnowienia_vec_data,
                                 long double odnowienia_exp_val,
                                 long double sum_ub_val)
{
    std::vector<long double> SU_dolna = odnowienia_vec_data[0];
    std::vector<long double> SU_gorna = odnowienia_vec_data[1];
    std::vector<long double> vec_odn = odnowienia_vec_data[2];
    std::vector<long double> vec_pra = odnowienia_vec_data[3];
    int ind = 0;
    int len_sub = SU_dolna.size();
    for (int i = 0; i < len_sub; i++)
    {
        if ((vec_odn[i] == odnowienia_exp_val) && (SU_dolna[i] <= sum_ub_val) && (SU_gorna[i] > sum_ub_val))
        {
            ind = i;
            break;
        }
    }
    return (vec_pra[ind]);
}


const std::string FOLDER_ODNOWIENIA = "csv/Odnowienia/";

std::vector<std::vector<long double>> read_odnowienia(const std::string filename)
{
    std::vector<std::vector<double>> odnowienia_vect;

    csvstream csvin(FOLDER_ODNOWIENIA + filename + ".csv");

    std::map<std::string, std::string> row;
    std::vector<double> pom_SU_dol_vec;
    std::vector<double> pom_SU_gor_vec;
    std::vector<double> pom_odn_vec;
    std::vector<double> pom_pr_odn_vec;

    while (csvin >> row)
    {
        pom_SU_dol_vec.push_back(std::stod(row["SU_dolnaGranica"]));
        pom_SU_gor_vec.push_back(std::stod(row["SU_gornaGranica"]));
        pom_odn_vec.push_back(std::stod(row["Odnowienie"]));
        pom_pr_odn_vec.push_back(std::stod(row["PrawdopodobienstwoOdnowienia"]));
    }

    odnowienia_vect.push_back(pom_SU_dol_vec);
    odnowienia_vect.push_back(pom_SU_gor_vec);
    odnowienia_vect.push_back(pom_odn_vec);
    odnowienia_vect.push_back(pom_pr_odn_vec);
}



   char odpowiedz;

    // pytanie do użytkownika
    std::cout << "Czy mają wystąpić odnowienia (t/n): ";
    std::cin >> odpowiedz;

    if (odpowiedz == 't' || odpowiedz == 'T')
    {
        std::cout << "Zaznaczono opcję odnowień.\n";
        odnowienia = 1;
    }
    else if (odpowiedz == 'n' || odpowiedz == 'N')
    {
        std::cout << "Nie zaznaczono opcji odnowień.\n";
        odnowienia = 0;
    }
    else
    {
        std::cout << "Nieprawidłowa odpowiedź. Wprowadź 't' lub 'n'.\n";
        return;
    }