import numpy as np
import pandas as pd

class PCG_XSH_RR:
    def __init__(self, seed=42, increment=54):
        self.state = seed
        self.increment = increment | 1  # The increment must be odd

    def pcg32(self):
        oldstate = self.state
        # Advance internal state
        self.state = (oldstate * 6364136223846793005 + self.increment) & ((1 << 64) - 1)
        # Calculate output function (XSH RR), uses old state for max ILP
        xorshifted = ((oldstate >> 18) ^ oldstate) >> 27
        rot = oldstate >> 59
        return (xorshifted >> rot) | (xorshifted << ((-rot) & 31)) & ((1 << 32) - 1)

    def random(self):
        return (self.pcg32() + 1) / float(1 << 32)  # Ensuring u1 is never 0

def generate_normal_pcg32(mean=0.0, std_dev=1.0, size=1, seed=42):
    pcg = PCG_XSH_RR(seed=seed)
    samples = []
    while len(samples) < size:
        # Using Box-Muller transform to generate normal distribution
        u1 = pcg.random()
        u2 = pcg.random()
        r = np.sqrt(-2 * np.log(u1))
        theta = 2 * np.pi * u2
        z0 = r * np.cos(theta)
        z1 = r * np.sin(theta)
        samples.append(mean + z0 * std_dev)
        if len(samples) < size:
            samples.append(mean + z1 * std_dev)
    return np.array(samples[:size])

# Generate 10 random numbers from a normal distribution
normal_samples = generate_normal_pcg32(size=10)
normal_samples_df = pd.DataFrame(normal_samples, columns=["Generated Normal Samples"])
import ace_tools as tools; tools.display_dataframe_to_user("Generated Normal Samples", normal_samples_df)
normal_samples_df
