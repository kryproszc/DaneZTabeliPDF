Grid2D& getQuadTree(std::vector<Grid2D>& quadtreeVector, int woj, int month)
{
    int index = woj * 12 + month;
    return quadtreeVector[index];
}


struct Point
{
    long double x, y;
    int insu;
    int reas;
    double premium;

    Point(long double x, long double y, int insu, int reas, double premium)
    {
        this->x = x;
        this->y = y;
        this->insu = insu;
        this->reas = reas;
        this->premium = premium;
    }
};

struct Rect
{
    double x1, y1, x2, y2;

    double width() const { return std::abs(x2 - x1); }
    double height() const { return std::abs(y2 - y1); }

    bool contains(const Point& p) const
    {
        return (p.x >= std::min(x1, x2) && p.x <= std::max(x1, x2) &&
            p.y >= std::min(y1, y2) && p.y <= std::max(y1, y2));
    }

    bool intersects(const Rect& range) const
    {
        return !(range.x1 > std::max(x1, x2) || range.x2 < std::min(x1, x2) ||
            range.y1 > std::max(y1, y2) || range.y2 < std::min(y1, y2));
    }
    bool contains(const Rect& other) const
    {
        return (std::min(x1, x2) <= std::min(other.x1, other.x2) &&
            std::max(x1, x2) >= std::max(other.x1, other.x2) &&
            std::min(y1, y2) <= std::min(other.y1, other.y2) &&
            std::max(y1, y2) >= std::max(other.y1, other.y2));
    }
};

class Grid2D
{
private:
    int rows, cols;
    Rect bounds;
    std::vector<Point*> grid; 

public:
    Grid2D(int rows, int cols, Rect bounds) : rows(rows), cols(cols), bounds(bounds)
    {
        grid.resize(rows * cols);  
    }
    bool insert(const Point& p)
    {
        if (!bounds.contains(p))
            return false;
        int col = static_cast<int>((p.x - bounds.x1) / ((bounds.x2 - bounds.x1) / cols));
        int row = static_cast<int>((p.y - bounds.y1) / ((bounds.y2 - bounds.y1) / rows));
        int index = row * cols + col;
        if (index >= 0 && index < rows * cols)
        {
            grid[index] = new Point(p); 
            return true;
        }
        return false;
    }
    void getPointsInRange(const Rect& range, std::vector<long double>& lat_sub,
        std::vector<long double>& lon_sub,
        std::vector<int>& insu_sub,
        std::vector<int>& reas_sub,
        std::vector<double>& premium_sub) const
    {
        int startCol = std::max(0, int((range.x1 - bounds.x1) / ((bounds.x2 - bounds.x1) / cols)));
        int endCol = std::min(cols - 1, int((range.x2 - bounds.x1) / ((bounds.x2 - bounds.x1) / cols)));
        int startRow = std::max(0, int((range.y1 - bounds.y1) / ((bounds.y2 - bounds.y1) / rows)));
        int endRow = std::min(rows - 1, int((range.y2 - bounds.y1) / ((bounds.y2 - bounds.y1) / rows)));
        for (int row = startRow; row <= endRow; ++row)
        {
            for (int col = startCol; col <= endCol; ++col)
            {
                int index = row * cols + col;
                if (grid[index] != nullptr && range.contains(*grid[index]))
                {
                    lat_sub.push_back(grid[index]->x);
                    lon_sub.push_back(grid[index]->y);
                    insu_sub.push_back(grid[index]->insu);
                    reas_sub.push_back(grid[index]->reas);
                    premium_sub.push_back(grid[index]->premium);
                }
            }
        }
    }

std::vector<Point> query(const Rect& range)
    {
        std::vector<Point> result;
        int startCol = std::max(0, int((range.x1 - bounds.x1) / ((bounds.x2 - bounds.x1) / cols)));
        int endCol = std::min(cols - 1, int((range.x2 - bounds.x1) / ((bounds.x2 - bounds.x1) / cols)));
        int startRow = std::max(0, int((range.y1 - bounds.y1) / ((bounds.y2 - bounds.y1) / rows)));
        int endRow = std::min(rows - 1, int((range.y2 - bounds.y1) / ((bounds.y2 - bounds.y1) / rows)));
        for (int row = startRow; row <= endRow; ++row)
        {
            for (int col = startCol; col <= endCol; ++col)
            {
                int index = row * cols + col;
                if (grid[index] != nullptr && range.contains(*grid[index]))
                {
                    result.push_back(*grid[index]);
                }
            }
        }
        return result;
    }

    ~Grid2D()
    {
        for (auto& p : grid)
        {
            delete p;  
        }
    }
};

Rect boundary = { 49.0, 16.07, 54.5, 24.09 };
std::vector<Grid2D> quadtree(17 * 12, Grid2D(100, 100, boundary));

void processRow(const std::string &startDate, const std::string &endDate, int region, double latitude, double longitude, int reassurance, double sumValue, int insurance)
{
    int startMonth = extractMonth(startDate) - 1;
    int endMonth = extractMonth(endDate) - 1;

    for (int month = startMonth; month <= endMonth; ++month)
    {

        getQuadTree(quadtree, region, month).insert({ latitude,longitude, insurance, reassurance, sumValue });

        exponsure_latitude[region][month].push_back(latitude);
        exponsure_longitude[region][month].push_back(longitude);
        exponsure_insurance[region][month].push_back(insurance);
        exponsure_reassurance[region][month].push_back(reassurance);
        exponsure_sum_value[region][month].push_back(sumValue);
    }
}

  Rect searchArea = {  lat_center - radius, lon_center - radius, lat_center + radius, lon_center + radius };

    getQuadTree(quadtree, woj, mies).getPointsInRange(searchArea, lat_sub, lon_sub, insu_sub, reas_sub, premium_sub);


    // for (int i = 0; i < n; i++)
    // {
    //     logical_value = !((exponsure_longitude[woj][mies][i] > east_lon) || (exponsure_longitude[woj][mies][i] < west_lon) || (exponsure_latitude[woj][mies][i] < south_lat) || (exponsure_latitude[woj][mies][i] > north_lat));
    //     if (logical_value)
    //     {
    //         lat_sub.push_back(exponsure_latitude[woj][mies][i]);
    //         lon_sub.push_back(exponsure_longitude[woj][mies][i]);
    //         insu_sub.push_back(exponsure_insurance[woj][mies][i]);
    //         reas_sub.push_back(exponsure_reassurance[woj][mies][i]);
    //         premium_sub.push_back(exponsure_sum_value[woj][mies][i]);
    //     }
    // }
