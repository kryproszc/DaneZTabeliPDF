import numpy as np
import pandas as pd

class PCG_XSH_RR:
    def __init__(self, seed=42, increment=54):
        self.state = seed
        self.increment = increment | 1  # The increment must be odd

    def pcg32(self):
        oldstate = self.state
        # Advance internal state
        self.state = (oldstate * 6364136223846793005 + self.increment) & ((1 << 64) - 1)
        # Calculate output function (XSH RR), uses old state for max ILP
        xorshifted = ((oldstate >> 18) ^ oldstate) >> 27
        rot = oldstate >> 59
        return (xorshifted >> rot) | (xorshifted << ((-rot) & 31)) & ((1 << 32) - 1)

    def random(self):
        return self.pcg32() / float(1 << 32)

def generate_normal_pcg32(mean=0.0, std_dev=1.0, size=1, seed=42):
    pcg = PCG_XSH_RR(seed=seed)
    samples = []
    while len(samples) < size:
        # Using Box-Muller transform to generate normal distribution
        u1 = pcg.random()
        u2 = pcg.random()
        if u1 <= 0.0:
            continue  # Skip to avoid log(0) or log(negative)
        r = np.sqrt(-2 * np.log(u1))
        theta = 2 * np.pi * u2
        z0 = r * np.cos(theta)
        z1 = r * np.sin(theta)
        samples.append(mean + z0 * std_dev)
        if len(samples) < size:
            samples.append(mean + z1 * std_dev)
    return np.array(samples[:size])